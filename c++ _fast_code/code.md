# IAIR C++ Style Guide
## 背景
C++是在项目中经常使用的开发语言，C++非常的强大，但是强大的同时也伴随着复杂，如果每个人都使用自己的风格书写代码，那么当项目在交接时，其他人阅读起来将会感到十分的吃力。

因为上面的原因我们在此处对C++代码风格进行规范化，要求在某些关键函数位置给予必要地注释，增加代码的可读性。

因为毕竟你在人机所学习和工作的时间里，你所书写的代码不会只给机器阅读，更重要的是留给之后的师妹师弟们用来学习和使用。即使，你所研究的方向非常的独特，与其他人交集很少。与大家保持一致的代码风格也是很有必要的，因为当你的代码出现头疼的bug，需要同学帮助你查看一下时，同样风格的代码互相审查起来也容易很多。

时刻记住，好的代码是给人读的，而不是仅仅给机器，交流与提升才是最重要的。

该代码风格，主要来自与[Google C++ style guide][2]。翻译参考了[Google 开源项目风格指南 (中文版)][1]，本文的作用是结合人机所项目代码要求与google C++ style guide所写，并且其中加入了理解和注释。

[1]:http://zh-google-styleguide.readthedocs.io/en/latest/
[2]:https://github.com/google/styleguide

## 1. Header Files（头文件）
一般情况下，每个 `.cc` 文件（unix下的C++文件，相当于win下的 `.cpp` ）都应该有一个相关的 `.h` 文件。一些例外的情况时，比如所书写的单靴测试代码段，或者非常小的.cc文件（仅仅包含一个 `main（）` function）。

作为规范代码风格的第一步，纠正使用头文件的方法会使得代码的可读性，长度以及代码性能有很大的不同。

### 1.1 Self-contained Headers（Self-contained 头文件）
头文件应该是自给自足型的（self-contained，也就是可以作为第一个头文件被引入），以 `.h` 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 `.inc` 结尾。不允许有分离出 `-inl.h` 头文件的做法.

所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有[1.2 The #define Guard](#1.2) 保护，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols.

如果 `.h` 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 `.cc` 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 `-inl.h` 文件里。

有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 `.cc` 文件里。

### 1.2 The #define Guard（#define 保护）
<h2 id="1.2">1.2 #define</h2>

```
所有头文件都应该使用 #define 来防止头文件被多重包含.
命名格式当是: <PROJECT>_<PATH>_<FILE>_H_ .
```
为保证唯一性，头文件的命名应该基于所在项目源代码树的全路径。例如，项目 `foo` 中的头文件 `foo/src/bar/baz.h` 可按如下方式保护:

```
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
…
#endif // FOO_BAR_BAZ_H_
```

### 1.3 Forward Declarations（前置声明）

```
尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
```

**定义**：

所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.

**优点**：

* 前置声明能够节省编译时间，多余的 `#include` 会迫使编译器展开更多的文件，处理更多的输入。
* 前置声明能够节省不必要的重新编译的时间。 `#include` 使代码因为头文件中无关的改动而被重新编译多次。

**缺点**：

* 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。
* 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 `API.` 例如扩大形参类型，加个自带默认参数的模板形参等等。
前置声明来自命名空间 `std::` 的 symbol 时，其行为未定义。
* 很难判断什么时候该用`前置声明`，什么时候该用 `#include` 。极端情况下，用前置声明代替 includes 甚至都会暗暗地改变代码的含义：

```

// b.h:
struct B {};
struct D : B {};

// good_user.cc:
#include "b.h"
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // calls f(B*)

```

如果 `#include` 被 `B` 和 `D` 的前置声明替代， `test()` 就会调用 `f(void*)`。
* 前置声明了不少来自头文件的 symbol 时，就会比单单一行的 `include` 冗长。
* 仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。

结论：
* 尽量避免前置声明那些定义在其他项目中的实体。
* 函数：总是使用 #include.
* 类模板：优先使用 #include.

### 1.4 Inline Functions（内联函数）
```
只有当函数只有 10 行甚至更少时才将其定义为内联函数。
```
**定义**：

当函数被声明为内联函数之后，编译器会将其内联展开，而不是按通常的函数调用机制进行调用。

**缺点**：

只要内联的函数体较小，内联该函数可以令目标代码更加高效。对于存取函数以及其它函数体比较短，性能关键的函数，鼓励使用内联。

**缺点**：

**滥用** 内联将导致程序变得 **更慢**。内联可能使目标代码量或增或减, 这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小，但内联一个相当大的函数将使得代码量剧增。现代处理器由于更好的利用了指令缓存，小巧的代码往往执行更快。

**结论**：

一个较为合理的经验准则是，不要内联超过10行的函数。谨慎对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用！

另一个实用的经验准则：内联那些包含循环或 `switch` 语句的函数常常是得不偿失 （除非在大多数情况下,这些循环或 `switch` 语句从不被执行）。

有些函数即使声明为内联的也不一定会被编译器内联，这点很重要；比如虚函数和递归函数就不会被正常内联。通常，递归函数不应该声明成内联函数。（递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数）。虚函数内联的主要原因则是想把它的函数体放在类定义内，为了图个方便，抑或是当作文档描述其行为，比如精短的存取函数。

### 1.5 Names and Order of Includes（#include 的路径及顺序）

```
使用标准的头文件包含顺序可增强可读性，避免隐藏依赖：
相关头文件，C 库，C++ 库，其他库的 .h，本项目内的 .h。
```

项目内头文件应按照项目源代码目录树结构排列, 避免使用`UNIX`特殊的快捷目录(当前目录) 或 .. (上级目录)。例如,
iair-awesome-project/src/base/logging.h 那么应该写成：
```
#include "base/logging.h"
```

再比如，`dir/foo.cc`的主要作用是实现或测试`dir2/foo2.h`的功能，foo.cc中包含头文件的次序应当如下排列：

```
1、dir2/foo2.h
2、C系统文件
3、C++系统文件
4、其他库的 .h 文件
5、项目内的 .h 文件
```

保持这样包含头文件顺序的好处是当 `dir2/foo2.h` 遗漏某些必要的库时，`dir/foo.cc` 或 `dir/foo_test.cc` 的构建会立刻终止。所以这一条规则的作用是使得维护这些文件的人是第一个看到构建终止的消息的，而不是维护其他包的人。

`dir/foo.cc` 和 `dir2/foo2.h` 通常位于同意目录下（如`base/basictypes_unittest.cc` 和 `base/basictypes.h`），当然如果你有更好地理由，也可以放在不同的目录下。

按首字母对头文件的包含顺序进行二次排序其实也不错。

代码中所以依赖的symbols被哪些头文件所定义，那么在书写时就应该包含哪些头文件，forward-declaration 情况除外。比如要用到 `bar.h` 中的某个symbols，哪怕你已经包含了的头文件 `foo.h` 已经包含了 `bar.h` ,也要照样包含 `bar.h` ,除非 `foo.h` 有明确的说明他会自动提供 `bar.h` 中的symbol。

但是 `.cc` 文件所对应的「相关头文件」已经包含的，就不用再重复包含进其 `.cc` 文件里面了，就像 `foo.cc` 只包含 `foo.h` 就够了，不用再管后者所包含的其它内容。


举例来说，`iair-awesome-project/src/foo/internal/fooserver.cc` 的包含次序如下：
```
#include "foo/public/fooserver.h" // 优先位置

#include <sys/types.h>
#include <unistd.h>

#include <hash_map>
#include <vector>

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/public/bar.h"
```

**但是**

有时，平台特定（system-specific）代码需要条件编译（conditional includes），这些代码可以放到其它 includes 之后。当然，平台特定代码也要够简练且独立，比如：
```
#include "foo/public/fooserver.h"

#include "base/port.h"  // For LANG_CXX11.

#ifdef LANG_CXX11
#include <initializer_list>
#endif  // LANG_CXX11
```

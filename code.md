# IAIR C++ Style Guide
## 背景
C++是在项目中经常使用的开发语言，C++非常的强大，但是强大的同时也伴随着复杂，如果每个人都使用自己的风格书写代码，那么当项目在交接时，其他人阅读起来将会感到十分的吃力。

因为上面的原因我们在此处对C++代码风格进行规范化，要求在某些关键函数位置给予必要地注释，增加代码的可读性。

因为毕竟你在人机所学习和工作的时间里，你所书写的代码不会只给机器阅读，更重要的是留给之后的师妹师弟们用来学习和使用。即使，你所研究的方向非常的独特，与其他人交集很少。与大家保持一致的代码风格也是很有必要的，因为当你的代码出现头疼的bug，需要同学帮助你查看一下时，同样风格的代码互相审查起来也容易很多。

时刻记住，好的代码是给人读的，而不是仅仅给机器，交流与提升才是最重要的。

该代码风格，主要来自与[Google C++ style guide][2]。翻译参考了[Google 开源项目风格指南 (中文版)][1]，本文的作用是结合人机所项目代码要求与google C++ style guide所写，并且其中加入了理解和注释。

[1]:http://zh-google-styleguide.readthedocs.io/en/latest/
[2]:https://github.com/google/styleguide
## 1. Header Files
一般情况下，每个 `.cc` 文件（unix下的C++文件，相当于win下的 `.cpp` ）都应该有一个相关的 `.h` 文件。一些例外的情况时，比如所书写的单靴测试代码段，或者非常小的.cc文件（仅仅包含一个 `main（）` function）。

作为规范代码风格的第一步，纠正使用头文件的方法会使得代码的可读性，长度以及代码性能有很大的不同。

### 1.1 Self-contained Headers
头文件应该是自给自足型的（self-contained,也就是可以作为第一个头文件被引入），以 `.h` 结尾。至于用来插入文本的文件，说到底它们并不是头文件，所以应以 `.inc` 结尾。不允许有分离出 `-inl.h` 头文件的做法.

所有头文件要能够自给自足。换言之，用户和重构工具不需要为特别场合而包含额外的头文件。详言之，一个头文件要有[1.2 The #define Guard](#1.2) 保护，统统包含它所需要的其它头文件，也不要求定义任何特别 symbols.

如果 `.h` 文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的 `.cc` 文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。不要把这些定义放到分离的 `-inl.h` 文件里。

有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 `.cc` 文件里。

### 1.2 The #define Guard
<h2 id="1.2">1.2 #define</h2>

```
所有头文件都应该使用 #define 来防止头文件被多重包含.
命名格式当是: <PROJECT>_<PATH>_<FILE>_H_ .
```
为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 `foo` 中的头文件 `foo/src/bar/baz.h` 可按如下方式保护:

```
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
…
#endif // FOO_BAR_BAZ_H_
```

### 1.3 Forward Declarations

```
尽可能地避免使用前置声明。使用 #include 包含需要的头文件即可。
```

**定义**：

所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义.

**优点**：

* 前置声明能够节省编译时间，多余的 `#include` 会迫使编译器展开更多的文件，处理更多的输入。
* 前置声明能够节省不必要的重新编译的时间。 `#include` 使代码因为头文件中无关的改动而被重新编译多次。

**缺点**：

* 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。
* 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其 `API.` 例如扩大形参类型，加个自带默认参数的模板形参等等。
前置声明来自命名空间 `std::` 的 symbol 时，其行为未定义。
* 很难判断什么时候该用`前置声明`，什么时候该用 `#include` 。极端情况下，用前置声明代替 includes 甚至都会暗暗地改变代码的含义：

```

// b.h:
struct B {};
struct D : B {};

// good_user.cc:
#include "b.h"
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // calls f(B*)

```

如果 `#include` 被 `B` 和 `D` 的前置声明替代， `test()` 就会调用 `f(void*)`。
* 前置声明了不少来自头文件的 symbol 时，就会比单单一行的 `include` 冗长。
* 仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂.
